\documentclass[UserManual.tex]{subfiles}
\begin{document}
\setcounter{section}{7}
\section{Template-Based Tutorial}\label{sec:tutorial}

\subsection{Overview}
A template project directory is provided that the User may copy to their own space, then use this as a foundation from which to embark on their own analysis. This directory includes information files, describing the parameter priors and the observables, that correspond to an artificial model that is also provided as a template. Working through the steps in this section constitutes a tutorial, both for running {\it Simplex Sampler} and for running {\it Smooth Emulator}.

This section describes the steps of how the User would
\begin{enumerate}\itemsep=0pt
\item Copy the required files from the template directory to the User's space, and compile the required programs.
\item Set up the information files describing the priors and observable names.
\item Run {\it Simplex Sampler} to generate the model-parameter values at which the full model will be trained.
\item Run an artificial full model to generate the observables for each of the full-model runs.
\item Tune {\it Smooth Emulator} and write the coefficients to file.
\item Run a program that prompts the User for the coordinates of a point in parameter space, then returns the emulator prediction with its uncertainty.
\end{enumerate}

\subsection{Installation}
After completing the necessary prerequisites listed in section \ref{sec:installation}[Installation] and following the steps outlined in section \ref{sec:installation}[Prerequisites] to install the required cmake, eigen, and gsl libraries, and setting the Home Environment Variable by creating the Home Directory as described in section \ref{sec:installation}[Making Home Directory and Setting Home Environment Variable], the user must proceed to clone the smooth and commonutils directories and compile the libraries, as explained in sections \ref{sec:installation}[Downloading] and [Compiling Libraries].

Then, the user can establish a personalized project directory by duplicating the project\_template directory onto their computer. The User needs to copy two directories, {\tt GITHOME\_BAND/SmoothEmulator/templates/mylocal} and {\tt GITHOME\_BAND/SmoothEmulator/templates/myproject} to locations in their personal space. We will refer to the User's two new directories as {\tt MY\_LOCAL/} and {\tt MY\_PROJECT/}. For the purpose of this tutorial, the User must compile three programs. This requires first changing into the {\tt MY\_LOCAL/build/} directory and entering:
{\tt
\begin{verbatim}
   MY_LOCAL/build% cmake .
   MY_LOCAL/build% make simplex
   MY_LOCAL/build% make smoothy_tune
   MY_LOCAL/build% make smoothy_calcobs
\end{verbatim}
}

\subsection{Creating Necessary Info Files}
Before a User can run {\it Simplex Sampler} they must create information files that describe the model-parameter priors and list the observable names. Both files are in the {\tt MY\_PROJECT} directory. The first file is {\tt MY\_PROJECT/Info/prior\_info.txt}. For the purposes of this tutorial, a file already exists,
{\tt
\begin{verbatim}
   par1 uniform      0.000      100.0
   par2 uniform      0.000      100.0
   par3 uniform      0.000      100.0
   par4 uniform      0.000      100.0
\end{verbatim}
}
This implies that the model has four parameters. The names, without much inspiration, are {\tt par1}, {\tt par2}, {\tt par3} and {\tt par4}. These names would normally be more descriptive, e.g. {\tt NuclearCompressibility}. The second entry in each line is either {\tt uniform} or {\tt gaussian}. If the parameter is {\tt uniform}, the last two numbers represent the range of the uniform prior, $x_{\rm min}$ and $x_{\rm max}$. If the second entry is {\tt gaussian} the third entry represents the center of the Gaussian distribution and the fourth represents the width. For a real model, the User would replace this model with one appropriate for their own model.

The second file is {\tt MY\_PROJECT/Info/observable\_info.txt}. This describes output values from the model. In the template the file is
{\tt
\begin{verbatim}
   length   meters   10.0
   mass     kg       30.0
   time     s        25.0
\end{verbatim}
}
The first entry in each line simply provides the names of the observable which will be processed in the Bayesian analysis. The second lists the units, and is never used, but is included for reference. The third entry is only used by {\tt Smooth Emulator} during tuning. The spread, $\sigma_A$, describes the variance of the output due to a single term in the Taylor expansion. Because this is treated as a random variable, and varied from one sampling of the coefficients to another, one must have an initial choice for it before the MCMC procedures in the tuning can proceed. One simple needs to choose this value within a few factors of two from the optimized value. Otherwise, the initial burn-in stage of the MCMC might require more time to coverge in the right neighborhood. Once the burn-in of the MCMC procedure is completed, this parameter is not used. 

\subsection{Running {\it Simplex Sampler}}

Both {\it Simplex Sampler} and {\tt Smooth Emulator} have options. These are provided in parameter files. For this tutorial, the provided parameter file is {\tt MY\_PROJECT/parameters/simplex\_parameters.txt}. The provided file is
{\tt
\begin{verbatim}
   #Simplex_LogFileName    simplexlog.txt # comment out to direct output to screen
   Simplex_TrainType       1              # Must be 1 or 2 or 3               
   Simplex_RTrain          0.95           # Radius of simplex    
   Simplex_ModelRunDirName modelruns      # Directory with training pt. info
\end{verbatim}
}
Because the first line is commented, the output of {\it Simplex Sampler} will be to the screen. Otherwise it would go to the specified file. By setting {\tt Simplex\_TrainType=1}, the sampler will choose $n+1$ training points, where $n=4$ is the number of model parameters. Each point corresponds to the vertices of an $n+1$ dimensional simplex. The parameter {\tt Simplex\_RTrain} sets the radius of the simplex, and needs to be less than one for a uniform distribution. The value of 0.95 ensures that the 5 training points are far from one another. Finally, the parameter {\tt Simplex\_ModelRunDirName} is set to ``{\tt modelruns}''. This informs {\tt Simplex Sampler} to write the coordinates of each training point and the corresponding observables in the directory {\tt MY\_PROJECT/modelruns/}. 

Now the user can run {\tt Simplex Sampler}, which must be run from the project directory,
 {\tt
\begin{verbatim}
   ~/MY_PROJECT% MY_LOCAL/bin/simplex parameters/simplex_parameters.txt
\end{verbatim}
}
If all goes, well there is no screen output. The programs writes information about the training points in the {\tt modelruns/} directory. Changing into that directory, there should now be five directories, corresponding to the training points at 5 places: {\tt modelruns/run0}, {\tt modelruns/run1}, {\tt modelruns/run2}, {\tt modelruns/run3}, and {\tt modelruns/run4}. Each directory has one text file describing the training points. For example, the {\tt modelruns/run0/mod\_parameters.txt} file is 
{\tt
\begin{verbatim}
   par1 18.3772
   par2 31.7426
   par3 37.0901
   par4 40
\end{verbatim}
}
This describes the four model parameters, which will serve as the input for the first full model run. If one had set the parameter {\tt Simplex\_TrainType} to 2, there would be 15 sub-directories in {\tt modelruns/}. The next step will be to run the full model for the parameters in each directory. Thus for {\tt Simplex\_Traintype=1}, one would need 5 full-model runs, and for {\tt Simplex\_Traintype=2}, one would need to do 15 full-model runs. The corresponding observables will be written in the files {\tt modelruns/runI/obs.txt}

\subsection{Running the Fake Full Model}
Once the training points have been generated, the user will input a Real full model based on the given structure, tailored to address their specific problem. For the tutorial, a fake model is provided. It reads the model-parameter values in each {\tt modelruns/runI/mod\_parameters.txt} file and writes the corresponding observables in {\tt modelruns/runI/obs.txt}. 

The fake model is a simple python script, which is enacted by entering the command:

{\tt
\begin{verbatim}
   MY_PROJECT% python3 MY_LOCAL/fakemodel/templatemod.py
\end{verbatim}
}
The output should appear as

{\tt
\begin{verbatim}
   MY_PROJECT% python3 MY_LOCAL/fakemodel/templatemod.py
   MY_PROJECT% Writing: length 10.871583624279312 1.0
   MY_PROJECT% Writing: mass -48.906793378963606 1.0
   MY_PROJECT% Writing: time -50.76565279455246 1.0

   MY_PROJECT% Writing: length -27.67701646408149 1.0
   MY_PROJECT% Writing: mass -50.35567713223607 1.0
   MY_PROJECT% Writing: time -34.04264570717603 1.0
   .
   .
\end{verbatim}
}
Inspecting the {\tt modelruns/run0/obs.txt} file,

{\tt
\begin{verbatim}
   length 10.871583624279312 1.0
   mass -48.906793378963606 1.0
   time -50.76565279455246 1.0
\end{verbatim}
}
The second entry of each line is the value of the specified observable for that specific training point. The last entry is the random uncertainty associated with the full model. This is only relevant if the model has random fluctuations, meaning the re-running the model at the same point might result in different output. For this tutorial, the emulator will not consider such fluctuations (there is an emulator parameter that can be set to either consider the randomness or ignore it), so the third entry on each line is superfluous.

\subsection{Running {\it Smooth Emulator}}
To tune the emulator, the User will run {\tt MY\_LOCAL/bin/SmoothEmulator\_tune} which should have been compiled in the directions above. The User needs to edit one additional file a this point, the parameter file that sets numerous options for {\it Smooth Emulator}. For the template used in this tutorial, that file is

{\tt
\begin{verbatim}
#SmoothEmulator_LogFileName smoothlog.txt
 SmoothEmulator_LAMBDA 3.0
 SmoothEmulator_MAXRANK 4
 SmoothEmulator_NASample 8  # No. of coefficient samples
 SmoothEmulator_TuneChooseMCMC true # set false if NPars<5
 SmoothEmulator_UseSigmaYRreal false # 
 SmoothEmulator_ConstrainA0 false
 SmoothEmulator_CutoffA false
 SmoothEmulator_ModelRunDirName modelruns
 SmoothEmulator_CoefficientsDirName coefficients
 SmoothEmulator_ModelParInfoDir    Info
 SmoothEmulator_ObservableInfoDir  Info
 SmoothEmulator_TrainingPts 0-4
 SmoothEmulator_MCStepSize 0.01
 SmoothEmulator_MCSigmaAStepSize 50.0
 SmoothEmulator_NMC 10000  # Steps between samples 
 SmoothEmulator_UsePCA   false
\end{verbatim}
}
The parameters are described in detail in Sec. \ref{sec:emulator}. For the purpose of this tutorial we review a few of them. The parameter {\tt SmoothEmulator\_TrainingPts} is set above to include all five of the training points. However, if {\it Simplex Sampler} were run with a different choice, or if the User had added more points to be used by some other means, this parameter should be adjusted. The three parameters, {\tt SmoothEmulator\_MCStepSize}, {\tt SmoothEmulator\_MCSigmaAStepSize} and {\tt SmoothEmulator\_NMC} might be adjusted depending on the rate of Monte Carlo convergence of the tuning.

Now, running {\tt smoothy\_tune}, produces the following output,

{\tt
\begin{verbatim}
MY_PROJECT% MY_LOCAL/bin/smoothy_tune parameters/emulator_parameters.txt
 Tuning Emulator for length
 success percentage=30.900000, SigmaA=170.951454, logP/Ndof=-0.604220,BestLogP/Ndof=-0.482655
 success percentage=29.980000, SigmaA=842.098167, logP/Ndof=-0.731110,BestLogP/Ndof=-0.544052
 success percentage=30.840000, SigmaA=184.488302, logP/Ndof=-0.651830,BestLogP/Ndof=-0.528882
 success percentage=31.330000, SigmaA=151.392117, logP/Ndof=-0.784629,BestLogP/Ndof=-0.583911
 success percentage=30.120000, SigmaA=120.719517, logP/Ndof=-0.588851,BestLogP/Ndof=-0.481046
 success percentage=29.950000, SigmaA=178.510175, logP/Ndof=-0.671494,BestLogP/Ndof=-0.495041
 success percentage=29.710000, SigmaA=281.210451, logP/Ndof=-0.750559,BestLogP/Ndof=-0.605111
 success percentage=29.930000, SigmaA=171.487852, logP/Ndof=-0.599591,BestLogP/Ndof=-0.521237
 Tuning Emulator for mass
 success percentage=19.490000, SigmaA=53.649126, logP/Ndof=-0.625247,BestLogP/Ndof=-0.492470
 success percentage=19.910000, SigmaA=84.204171, logP/Ndof=-0.656591,BestLogP/Ndof=-0.527139
 success percentage=17.380000, SigmaA=46.138790, logP/Ndof=-0.780594,BestLogP/Ndof=-0.573535
 success percentage=18.750000, SigmaA=92.444543, logP/Ndof=-0.531562,BestLogP/Ndof=-0.505887
 success percentage=19.190000, SigmaA=60.575128, logP/Ndof=-0.540636,BestLogP/Ndof=-0.457436
 success percentage=17.920000, SigmaA=75.219279, logP/Ndof=-0.674120,BestLogP/Ndof=-0.539112
 success percentage=18.360000, SigmaA=40.116381, logP/Ndof=-0.656642,BestLogP/Ndof=-0.557670
 success percentage=19.470000, SigmaA=74.261850, logP/Ndof=-0.675975,BestLogP/Ndof=-0.564430
 Tuning Emulator for time
 success percentage=19.760000, SigmaA=82.486706, logP/Ndof=-0.669089,BestLogP/Ndof=-0.489885
 success percentage=19.970000, SigmaA=44.492860, logP/Ndof=-0.632434,BestLogP/Ndof=-0.497695
 success percentage=19.520000, SigmaA=80.956164, logP/Ndof=-0.682640,BestLogP/Ndof=-0.549880
 success percentage=19.340000, SigmaA=70.625835, logP/Ndof=-0.668105,BestLogP/Ndof=-0.518805
 success percentage=19.590000, SigmaA=116.988915, logP/Ndof=-0.673993,BestLogP/Ndof=-0.582763
 success percentage=19.080000, SigmaA=89.891122, logP/Ndof=-0.631130,BestLogP/Ndof=-0.508224
 success percentage=19.880000, SigmaA=102.710384, logP/Ndof=-0.707850,BestLogP/Ndof=-0.542698
 success percentage=19.450000, SigmaA=206.622539, logP/Ndof=-0.800493,BestLogP/Ndof=-0.486518
\end{verbatim}
}

If the success percentage above is small, much less than 50\%, then one may wish to decrease the Monte Carlo stepsizes, {\tt SmoothEmulator\_MCStepSize} and {\tt SmoothEmulator\_MCSigmaAStepSize 0.01}, to increase the success rate of the Metropolis steps. If the percentage is large, much greater than 50\%, conversely, one may wish to increase the step size to increase the coverage of the Monte Carlo trace. The quantity {\tt SigmaA} represents the characteristic width of the distributions of coefficients. It is allowed to vary, and from experience, the range can be quite large. If the value of {\tt SigmaA} does not seem to have randomized, one may wish to increase the number of Monte Carlo steps, {\tt  SmoothEmulator\_NMC}. The quantitiy {\tt logP/Ndof} is the logarithm of the weight for a coefficient set divided by the number of degrees of freedom (number of coefficients). It should fluctuate throughout the trace. Higher values (usually less negative) indicate better fits. If the value is well below -1, and rising throughout the trace, it suggests the burn-in was insufficient and {\tt  SmoothEmulator\_NMC} should be increased. The last entry in the output lines, {\tt BestLogP/Ndof}, simply reports the highest weight encountered in the trace. Again, if that is significantly increasing throughout the trace, {\tt  SmoothEmulator\_NMC} should be increased. 

To represent the uncertainty, there were $N_{\rm sample}$ sets of coefficients generated by {\it Smooth Emulator}. In this case, the parameter {\tt SmoothEmulator\_NASample} was set to 8. As the Monte Carlo trace proceeds, after {\tt SmoothEmulator\_NMC} steps, the coefficients are stored, and an output line is generated as seen above. Thus there are 8 lines printed above for each observable.

The program generates Taylor coefficients for $N_{\rm sample}$ samples and saves them in the {\tt coefficients} directory. Each observable has its own sub-directory with its name. Besides the coefficients, {\it Smooth Emulator} also produces a {\tt meta.txt} file in the same directory. It includes essential information like the observable's maximum rank and net number of model parameters. This file is used to access the coefficients later. In this case, {\tt smoothy\_tune} created the directories, {\tt MY\_PROJECT/coefficients/length},  {\tt MY\_PROJECT/coefficients/mass} and {\tt MY\_PROJECT/coefficients/time}. Within each of these sub-directories {\tt smoothy\_tune} created files {\tt meta.txt}, {\tt sample0.txt}, {\tt sample1.text} $\cdots$ {\tt sample7.txt}.


\section{Generating Emulated Observables}
Finally, now that the emulator is tuned, one may wish to generate emulated values for the observables for specified points in model-parameter space. A sample program, {\tt MY\_LOCAL/bin/smoothy\_calcobs} is provided to illustrate how this can be accomplished. If one invokes the executable, using the same parameters as those used by {\tt smoothy\_tune}, the User is prompted to enter the coordinates of a point in model-parameter space, after which {\tt smoothy\_calcobs} prints out the observables. In this case, for the case where {\tt par1=20}, {\tt par2=40}, {\tt par3=60} and {\tt par4=80},

{\tt
\begin{verbatim}
MY_PROJECT% MY_LOCAL/bin/smoothy_calcobs parameters/emulator_parameters.txt
Prior Info
#         ParameterName Type   Xmin_or_Xbar  Xmax_or_SigmaX
 0:            par1   uniform          0        100
 1:            par2   uniform          0        100
 2:            par3   uniform          0        100
 3:            par4   uniform          0        100
Enter value for par1:
20
Enter value for par2:
40
Enter value for par3:
60
Enter value for par4:
80
length = 61.349 +/- 5.14857
mass = -26.4496 +/- 2.6206
time = -44.9779 +/- 2.0495
\end{verbatim}
}

One can test the emulator by entering the coordinates of training point. For example, one of the training points is {\tt par1=50}, {\tt par2=50}, {\tt par3=88.7298} and {\tt par4=40}. Running {\tt smoothy\_calcobs} for that coordinate,

{\tt
\begin{verbatim}
MY_PROJECT% MY_LOCAL/bin/smoothy_calcobs parameters/emulator_parameters.txt
Prior Info
#         ParameterName Type   Xmin_or_Xbar  Xmax_or_SigmaX
 0:            par1   uniform          0        100
 1:            par2   uniform          0        100
 2:            par3   uniform          0        100
 3:            par4   uniform          0        100
Enter value for par1:
50
Enter value for par2:
50
Enter value for par3:
88.7298
Enter value for par4:
40
length = -45.878 +/- 6.7435e-07
mass = -7.8083 +/- 8.42937e-08
time = -52.4031 +/- 1.16801e-06
\end{verbatim}
}
Note that the uncertainties for the emulation are not effectivly zero, as each set of the 8 sets of coefficients provides an an emulator that exactly reproduces the training points.

Of course, it is unlikely the User will wish to enter model parameters interactively as was done above. To incorporate {\tt Smooth Emulator} into other programs, the User should inspect the main program, {\tt MY\_LOCAL/main\_programs/smoothy\_calcobs\_main.cc}. The User can then design their own program based on this source code, and compile and link it by editing {\tt MY\_LOCAL/build/CMakeLists.txt}. By editing the CMake file, replacing the lines unique to {\tt smoothy\_calcobs}, one can easily compile new executables based on the User's main programs. To understand what might be involved, the source code in {\tt MY\_LOCAL/main\_programs/SmoothEmulator\_calcobs\_main.cc} is
{\tt
\begin{verbatim}
#include "msu_commonutils/parametermap.h"
#include "msu_smooth/master.h"
#include "msu_commonutils/log.h"
using namespace std;

 int main(int argc,char *argv[]){
   if(argc!=2){
      CLog::Info("Usage smoothy_calcobs emulator parameter filename");
      exit(1);
   }
   CparameterMap *parmap=new CparameterMap();
   parmap->ReadParsFromFile(string(argv[1]));
   CSmoothMaster master(parmap);
   master.ReadCoefficientsAllY();
   
   CModelParameters *modpars=new CModelParameters(master.priorinfo); // contains info about single point
   
   master.priorinfo->PrintInfo();
   // Prompt user for model parameter values
   vector<double> X(modpars->NModelPars);
   for(int ipar=0;ipar<modpars->NModelPars;ipar++){
      cout << "Enter value for " << master.priorinfo->GetName(ipar) << ":\n";
      cin >> X[ipar];
   }
   modpars->SetX(X);
   
   //  Calc Observables
   CObservableInfo *obsinfo=master.observableinfo;
   vector<double> Y(obsinfo->NObservables);
   vector<double> SigmaY(obsinfo->NObservables);
   master.CalcAllY(modpars,Y,SigmaY);
   for(int iY=0;iY<obsinfo->NObservables;iY++){
      cout << obsinfo->GetName(iY) << " = " << Y[iY] << " +/- " << SigmaY[iY] << endl;
   }

   return 0;
}
\end{verbatim}
}
This illustrates how one can write a code that 
\begin{itemize}\itemsep=0pt
\item[a)] Reads the parameter file
\item[b)] Creates a {\it master} emulator file (called master because it includes emulators for all the observables)
\item[c)] Creates a model-parameters object, {\tt modpars}, that stores the coordinates of the model-parameter point
\item[d)] Calculates the observables from the emulator
\end{itemize}


\end{document}
